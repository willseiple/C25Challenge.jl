var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = C25Challenge","category":"page"},{"location":"#C25Challenge","page":"Home","title":"C25Challenge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for C25Challenge.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using C25Challenge\nproblem = Problem()\nsolution = series_solver(problem)","category":"page"},{"location":"#Algorithm","page":"Home","title":"Algorithm","text":"","category":"section"},{"location":"#Greedy-Approach","page":"Home","title":"Greedy Approach","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For our initial implementation, we created a naive greedy algorithm maximizing a heuristic representing rate of score accrual. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This heuristic works as follows: if a certain edge has not been visited, its value is distance / duration (speed limit), otherwise we multiply this value by k^(number of times visited) (we chose a value of 0.3 for k). We initially made visited edges worth 0, but found that this is not very useful in the case where all immediate edges have been visited, and it is reasonable to choose the road least traveled (or one with over 1/k times that road's speed limit, which may propel the car into a different part of the city).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For each car, we calculate its entire path by selecting the edge that maximizes our heuristic. We then increment the number of times that edge has been visited and repeat. This algorithm runs in O(cE) time, where c is the number of cars and E is the average number of roads taken for any car (total time allowed / average time per road), so with 8 cars O(E). This resulted in fairly mediocre results, with cars failing to explore many regions of the city, but was extremely fast.","category":"page"},{"location":"#Greedy-Lookahead-Approach-in-Series","page":"Home","title":"Greedy Lookahead Approach in Series","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We then upgraded our design by implementing a lookahead into a very similar algorithm. Instead of selecting the next edge for a car at a given junction by choosing the road that maximized our heuristic, we chose the first edge in the path of a specified length d (in number of junctions) with the highest average heuristic. Our implementation of the lookahead at a given junction queries neighboring junctions for the cumulative heuristic of a path of length d-1 from that junction, and chooses the junction with the highest total cumulative heuristic + the heuristic resulting in traversing that edge. Our algorithm then takes one step to that junction and repeats. For each car, this algorithm takes E steps, where E is the average number of roads taken for any car (total time allowed / average time per road), and at each step it carries out a lookahead of time V^d, where V is the average number of neighbors at a given junction, and d is the depth of the lookahead (constant). This gives us a complexity of O(cEV^d), or with 8 cars, O(EV^d). Using this algorithm, we were able to reach a distance of 1,820,000 at a depth of 8, with impressive coverage of the city and logical car behavior when inspected visually.","category":"page"},{"location":"#Greedy-Lookahead-Approach-in-Parallel","page":"Home","title":"Greedy Lookahead Approach in Parallel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We tried a number of augmentations to the lookahead algorithm, including parallelizing (sort of) the progress of each of the cars. Instead of allowing the cars to traverse the graph all in one turn, we had the cars take one step on each turn. This algorithm has the same runtime as the previous series approach, but led to a slight improvement, as the cars gained more information about the actions of the other cars as time went on. We were able to reach a total distance of 1,852,994 at a depth of 8.","category":"page"},{"location":"#Upper-Bound","page":"Home","title":"Upper Bound","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When considering the upper bound, we came up with the following algorithm. We order the streets primarily by rate of travel (fastest first), and secondarily by distance (shortest first). We initialize two pointers. We iterate over the streets one at a time with the first pointer, keeping track of the total cumulative duration, and the duration of the streets in the current iteration, until the next street would result in going over the time limit. Then, we continue iterating with the second pointer until we find an edge with a duration less than the remaining available time (repeating this part until no more can be found), and marking these streets to be skipped by the first pointer. We repeat this for each car, resetting the second pointer but maintaining the first pointer, in order to see the maximum distance achievable if each car were always traveling on the current fastest, untravelled street that can be traversed within the time limit. This will maximize what is achievable in a feasible solution, and is an upper bound to the problem.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [C25Challenge]","category":"page"},{"location":"#C25Challenge.EdgeWeight","page":"Home","title":"C25Challenge.EdgeWeight","text":"EdgeWeight\n\nStores the weight of an edge in a StreetGraph\n\nFields\n\nduration::Integer : The duration to traverse the edge or street\nrate::Float64: The rate of taking the edge or street\nnvisited::Float64: The number of times the edge has been visited\n\n\n\n\n\n","category":"type"},{"location":"#C25Challenge.StreetGraph","page":"Home","title":"C25Challenge.StreetGraph","text":"StreetGraph\n\nMaster graph representing the street system of a City, wrapper for ValOutDiGraph and stores other properties of the problem.\n\nFields\n\ngraph::SimpleValueGraphs.ValOutDiGraph: Graph Representation of the City \nN::Integer: number of cars\nstart::Integer: The index of the initial junction\ntotalTime::Integer: time limit of the problem\n\n\n\n\n\n","category":"type"},{"location":"#C25Challenge.Problem-Tuple{}","page":"Home","title":"C25Challenge.Problem","text":"Problem()\n\nReturn a StreetGraph\n\n\n\n\n\n","category":"method"},{"location":"#C25Challenge.bestStepLookahead","page":"Home","title":"C25Challenge.bestStepLookahead","text":"bestStepLookahead(graph::StreetGraph, currentNode::Integer, depth=5)\n\nA lookahead function that calulates a heuristic and returns the corresponding next best node.\n\nParameters\n\ngraph: The graph format of the City\ncurrentNode: The current junction or node we are looking ahead after\ndepth: The depth of the lookahead search\n\n\n\n\n\n","category":"function"},{"location":"#C25Challenge.compute_distance-Tuple{HashCode2014.Solution}","page":"Home","title":"C25Challenge.compute_distance","text":"compute_distance(solution::Solution)\n\nComputes the total distance of all itineraries in solution based on the StreetGraph Streets visited several times are only counted once.\n\n\n\n\n\n","category":"method"},{"location":"#C25Challenge.feasible_check-Tuple{HashCode2014.Solution}","page":"Home","title":"C25Challenge.feasible_check","text":"feasible_check(Solution)\n\nCheck if solution satisfies the constraints of the problme statement The following criteria are considered:\n\nthe number of itineraries has to match the number of cars that traverse the city`\nthe first junction of each itinerary has to be the starting junction of city\nfor each consecutive pair of junctions on an itinerary, a street connecting these junctions has to exist in city (if the street is one directional, it has to be traversed in the correct direction)\nthe duration of each itinerary has to be lower or equal to the total duration of city\n\n\n\n\n\n","category":"method"},{"location":"#C25Challenge.outInformation-Tuple{StreetGraph, Integer}","page":"Home","title":"C25Challenge.outInformation","text":"outInformation(g::StreetGraph, node::Integer)\n\nReturns the information about the node, specifically: outedgevals, outneighbors, and max rate index    \n\nParameters\n\nstreetGraph: The graph format of the City\nnode: The node on the graph format to get information about\n\n\n\n\n\n","category":"method"},{"location":"#C25Challenge.parallel_solver","page":"Home","title":"C25Challenge.parallel_solver","text":"parallel_solver(streetGraph::StreetGraph, lookahead=5)\n\nA greedy algorithm that solves the problem by sending the cars all at once\n\nParameters\n\nstreetGraph: The graph format of the City\nlookahead: The number of steps to lookahead\n\n\n\n\n\n","category":"function"},{"location":"#C25Challenge.random_parallel_solver","page":"Home","title":"C25Challenge.random_parallel_solver","text":"random_parallel_solver(streetGraph::StreetGraph, lookahead=5, pct_chance=5)\n\nA greedy algorithm that solves the problem in parallel but with random chance of going again\n\nParameters\n\nstreetGraph: The graph format of the City\nlookahead: The number of steps to lookahead\npct_chance: Drives random behavior for a car to go again\n\n\n\n\n\n","category":"function"},{"location":"#C25Challenge.series_solver","page":"Home","title":"C25Challenge.series_solver","text":"series_solver(streetGraph::StreetGraph, lookahead=5)\n\nA greedy algorithm that solves the problem by sending the cars one after another.\n\nParameters\n\nstreetGraph: The graph format of the City\nlookahead: The number of steps to lookahead\n\n\n\n\n\n","category":"function"}]
}
