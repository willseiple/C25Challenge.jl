<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · C25Challenge.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://willseiple.github.io/C25Challenge.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>C25Challenge.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Algorithm"><span>Algorithm</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/willseiple/C25Challenge.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="C25Challenge"><a class="docs-heading-anchor" href="#C25Challenge">C25Challenge</a><a id="C25Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#C25Challenge" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/willseiple/C25Challenge.jl">C25Challenge</a>.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><pre><code class="language-julia hljs">using C25Challenge
problem = Problem()
solution = series_solver(problem)</code></pre><h2 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h2><h3 id="Greedy-Approach"><a class="docs-heading-anchor" href="#Greedy-Approach">Greedy Approach</a><a id="Greedy-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-Approach" title="Permalink"></a></h3><p>For our initial implementation, we created a naive greedy algorithm maximizing a heuristic representing rate of score accrual. </p><p>This heuristic works as follows: if a certain edge has not been visited, its value is distance / duration (speed limit), otherwise we multiply this value by k^(number of times visited) (we chose a value of 0.3 for k). We initially made visited edges worth 0, but found that this is not very useful in the case where all immediate edges have been visited, and it is reasonable to choose the road least traveled (or one with over 1/k times that road&#39;s speed limit, which may propel the car into a different part of the city).</p><p>For each car, we calculate its entire path by selecting the edge that maximizes our heuristic. We then increment the number of times that edge has been visited and repeat. This algorithm runs in O(cE) time, where c is the number of cars and E is the average number of roads taken for any car (total time allowed / average time per road), so with 8 cars O(E). This resulted in fairly mediocre results, with cars failing to explore many regions of the city, but was extremely fast.</p><h3 id="Greedy-Lookahead-Approach-in-Series"><a class="docs-heading-anchor" href="#Greedy-Lookahead-Approach-in-Series">Greedy Lookahead Approach in Series</a><a id="Greedy-Lookahead-Approach-in-Series-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-Lookahead-Approach-in-Series" title="Permalink"></a></h3><p>We then upgraded our design by implementing a lookahead into a very similar algorithm. Instead of selecting the next edge for a car at a given junction by choosing the road that maximized our heuristic, we chose the first edge in the path of a specified length d (in number of junctions) with the highest average heuristic. Our implementation of the lookahead at a given junction queries neighboring junctions for the cumulative heuristic of a path of length d-1 from that junction, and chooses the junction with the highest total cumulative heuristic + the heuristic resulting in traversing that edge. Our algorithm then takes one step to that junction and repeats. For each car, this algorithm takes E steps, where E is the average number of roads taken for any car (total time allowed / average time per road), and at each step it carries out a lookahead of time V^d, where V is the average number of neighbors at a given junction, and d is the depth of the lookahead (constant). This gives us a complexity of O(cEV^d), or with 8 cars, O(EV^d). Using this algorithm, we were able to reach a distance of 1,820,000 at a depth of 8, with impressive coverage of the city and logical car behavior when inspected visually.</p><h3 id="Greedy-Lookahead-Approach-in-Parallel"><a class="docs-heading-anchor" href="#Greedy-Lookahead-Approach-in-Parallel">Greedy Lookahead Approach in Parallel</a><a id="Greedy-Lookahead-Approach-in-Parallel-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-Lookahead-Approach-in-Parallel" title="Permalink"></a></h3><p>We tried a number of augmentations to the lookahead algorithm, including parallelizing (sort of) the progress of each of the cars. Instead of allowing the cars to traverse the graph all in one turn, we had the cars take one step on each turn. This algorithm has the same runtime as the previous series approach, but led to a slight improvement, as the cars gained more information about the actions of the other cars as time went on. We were able to reach a total distance of 1,852,994 at a depth of 8.</p><h3 id="Upper-Bound"><a class="docs-heading-anchor" href="#Upper-Bound">Upper Bound</a><a id="Upper-Bound-1"></a><a class="docs-heading-anchor-permalink" href="#Upper-Bound" title="Permalink"></a></h3><p>When considering the upper bound, we came up with the following algorithm. We order the streets primarily by rate of travel (fastest first), and secondarily by distance (shortest first). We initialize two pointers. We iterate over the streets one at a time with the first pointer, keeping track of the total cumulative duration, and the duration of the streets in the current iteration, until the next street would result in going over the time limit. Then, we continue iterating with the second pointer until we find an edge with a duration less than the remaining available time (repeating this part until no more can be found), and marking these streets to be skipped by the first pointer. We repeat this for each car, resetting the second pointer but maintaining the first pointer, in order to see the maximum distance achievable if each car were always traveling on the current fastest, untravelled street that can be traversed within the time limit. This will maximize what is achievable in a feasible solution, and is an upper bound to the problem.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#C25Challenge.EdgeWeight"><code>C25Challenge.EdgeWeight</code></a></li><li><a href="#C25Challenge.StreetGraph"><code>C25Challenge.StreetGraph</code></a></li><li><a href="#C25Challenge.Problem-Tuple{}"><code>C25Challenge.Problem</code></a></li><li><a href="#C25Challenge.bestStepLookahead"><code>C25Challenge.bestStepLookahead</code></a></li><li><a href="#C25Challenge.compute_distance-Tuple{HashCode2014.Solution}"><code>C25Challenge.compute_distance</code></a></li><li><a href="#C25Challenge.feasible_check-Tuple{HashCode2014.Solution}"><code>C25Challenge.feasible_check</code></a></li><li><a href="#C25Challenge.outInformation-Tuple{StreetGraph, Integer}"><code>C25Challenge.outInformation</code></a></li><li><a href="#C25Challenge.parallel_solver"><code>C25Challenge.parallel_solver</code></a></li><li><a href="#C25Challenge.random_parallel_solver"><code>C25Challenge.random_parallel_solver</code></a></li><li><a href="#C25Challenge.series_solver"><code>C25Challenge.series_solver</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.EdgeWeight" href="#C25Challenge.EdgeWeight"><code>C25Challenge.EdgeWeight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EdgeWeight</code></pre><p>Stores the weight of an edge in a StreetGraph</p><p><strong>Fields</strong></p><ul><li><code>duration::Integer</code> : The duration to traverse the edge or street</li><li><code>rate::Float64</code>: The rate of taking the edge or street</li><li><code>nvisited::Float64</code>: The number of times the edge has been visited</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/structs/EdgeWeight.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.StreetGraph" href="#C25Challenge.StreetGraph"><code>C25Challenge.StreetGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StreetGraph</code></pre><p>Master graph representing the street system of a City, wrapper for ValOutDiGraph and stores other properties of the problem.</p><p><strong>Fields</strong></p><ul><li><code>graph::SimpleValueGraphs.ValOutDiGraph</code>: Graph Representation of the City </li><li><code>N::Integer</code>: number of cars</li><li><code>start::Integer</code>: The index of the initial junction</li><li><code>totalTime::Integer</code>: time limit of the problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/structs/graph.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.Problem-Tuple{}" href="#C25Challenge.Problem-Tuple{}"><code>C25Challenge.Problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Problem()</code></pre><p>Return a <a href="#C25Challenge.StreetGraph"><code>StreetGraph</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/structs/graph.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.bestStepLookahead" href="#C25Challenge.bestStepLookahead"><code>C25Challenge.bestStepLookahead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bestStepLookahead(graph::StreetGraph, currentNode::Integer, depth=5)</code></pre><p>A lookahead function that calulates a heuristic and returns the corresponding next best node.</p><p><strong>Parameters</strong></p><ul><li><code>graph</code>: The graph format of the City</li><li><code>currentNode</code>: The current junction or node we are looking ahead after</li><li><code>depth</code>: The depth of the lookahead search</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/util/helpers.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.compute_distance-Tuple{HashCode2014.Solution}" href="#C25Challenge.compute_distance-Tuple{HashCode2014.Solution}"><code>C25Challenge.compute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_distance(solution::Solution)</code></pre><p>Computes the total distance of all itineraries in <code>solution</code> based on the StreetGraph Streets visited several times are only counted once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/util/evaluate.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.feasible_check-Tuple{HashCode2014.Solution}" href="#C25Challenge.feasible_check-Tuple{HashCode2014.Solution}"><code>C25Challenge.feasible_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feasible_check(Solution)</code></pre><p>Check if <code>solution</code> satisfies the constraints of the problme statement The following criteria are considered:</p><ul><li>the number of itineraries has to match the number of cars that traverse the <code>city</code>`</li><li>the first junction of each itinerary has to be the starting junction of <code>city</code></li><li>for each consecutive pair of junctions on an itinerary, a street connecting these junctions has to exist in <code>city</code> (if the street is one directional, it has to be traversed in the correct direction)</li><li>the duration of each itinerary has to be lower or equal to the total duration of <code>city</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/util/evaluate.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.outInformation-Tuple{StreetGraph, Integer}" href="#C25Challenge.outInformation-Tuple{StreetGraph, Integer}"><code>C25Challenge.outInformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outInformation(g::StreetGraph, node::Integer)</code></pre><p>Returns the information about the node, specifically: outedgevals, outneighbors, and max rate index    </p><p><strong>Parameters</strong></p><ul><li><code>streetGraph</code>: The graph format of the City</li><li><code>node</code>: The node on the graph format to get information about</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/util/helpers.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.parallel_solver" href="#C25Challenge.parallel_solver"><code>C25Challenge.parallel_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallel_solver(streetGraph::StreetGraph, lookahead=5)</code></pre><p>A greedy algorithm that solves the problem by sending the cars all at once</p><p><strong>Parameters</strong></p><ul><li><code>streetGraph</code>: The graph format of the City</li><li><code>lookahead</code>: The number of steps to lookahead</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/solvers/parallel.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.random_parallel_solver" href="#C25Challenge.random_parallel_solver"><code>C25Challenge.random_parallel_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_parallel_solver(streetGraph::StreetGraph, lookahead=5, pct_chance=5)</code></pre><p>A greedy algorithm that solves the problem in parallel but with random chance of going again</p><p><strong>Parameters</strong></p><ul><li><code>streetGraph</code>: The graph format of the City</li><li><code>lookahead</code>: The number of steps to lookahead</li><li><code>pct_chance</code>: Drives random behavior for a car to go again</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/solvers/random.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="C25Challenge.series_solver" href="#C25Challenge.series_solver"><code>C25Challenge.series_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">series_solver(streetGraph::StreetGraph, lookahead=5)</code></pre><p>A greedy algorithm that solves the problem by sending the cars one after another.</p><p><strong>Parameters</strong></p><ul><li><code>streetGraph</code>: The graph format of the City</li><li><code>lookahead</code>: The number of steps to lookahead</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willseiple/C25Challenge.jl/blob/4cf03275d8dec29ba6666f6034bc22b853cef9b9/src/solvers/series.jl#L1-L9">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 17 December 2022 05:34">Saturday 17 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
